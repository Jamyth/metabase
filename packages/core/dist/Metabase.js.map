{"version":3,"file":"Metabase.js","sourceRoot":"","sources":["../src/Metabase.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kDAAiD;AACjD,2CAAsD;AAGtD;IAAA;IA4CA,CAAC;IA3CU,wBAAe,GAAtB,UAA0B,MAAsB;QAC5C,OAAO,OAAO,CAAC,WAAW,CAAC,yBAAY,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;IAC3D,CAAC;IAEM,wBAAe,GAAtB,UAA0B,MAAsB;QAC5C,IAAM,WAAW,GAAG,QAAQ,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACrD,IAAM,MAAM,GAAG,OAAO,CAAC,WAAW,CAAC,qBAAQ,EAAE,MAAM,CAAC,IAAI,KAAK,CAAC;QAC9D,IAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC;QAC3B,IAAM,OAAO,GAAG,IAAI,yBAAW,EAAE,CAAC;QAClC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACxB,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QAC1B,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAC1B,OAAO,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACnC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC7B,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAC7B,OAAO,OAAO,CAAC,KAAK,EAAE,CAAC;IAC3B,CAAC;IAEM,gCAAuB,GAA9B,UAAkC,MAAsB;QACpD,OAAO,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;IAC/E,CAAC;IAEc,qCAA4B,GAA3C,UAA+C,QAAiB,EAAE,MAAe;QAC7E,IAAM,IAAI,GAAG,QAAQ,CAAC,UAAU,IAAI,MAAM,CAAC,CAAC,CAAC,UAAG,MAAM,cAAI,QAAQ,CAAC,IAAI,CAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC1F,IAAM,cAAc,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC;QAC9D,IAAM,aAAa,GAAG,QAAQ,CAAC,YAAY,EAAE,CAAC;QAE9C,IAAM,UAAU,GAAe;YAC3B,IAAI,MAAA;YACJ,IAAI,EAAE,cAAc;YACpB,UAAU,EAAE,aAAa;SAC5B,CAAC;QAEF,IAAI,QAAQ,CAAC,MAAM,EAAE;YACjB,OAAO,CAAC,UAAU,CAAC,CAAC;SACvB;QAED,IAAM,QAAQ,GAAgB,QAAQ,CAAC,IAAI;YACvC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,UAAC,CAAY,IAAK,OAAA,CAAC,CAAC,CAAC,WAAW,EAAd,CAAc,CAAC;YACvE,CAAC,CAAC,EAAE,CAAC;QAET,sBAAQ,UAAU,UAAK,QAAQ,CAAC,OAAO,CAAC,UAAC,CAAC,IAAK,OAAA,QAAQ,CAAC,4BAA4B,CAAC,CAAC,EAAE,IAAI,CAAC,EAA9C,CAA8C,CAAC,UAAE;IACpG,CAAC;IACL,eAAC;AAAD,CAAC,AA5CD,IA4CC;AA5CY,4BAAQ","sourcesContent":["import { TypeBuilder } from './util/TypeBuilder';\nimport { ENUM_KEY, PROPERTY_KEY } from './decorators';\nimport type { Constructor, PropertyTree, Type, Definition } from './type';\n\nexport class Metabase {\n    static getPropertyTree<T>(object: Constructor<T>): PropertyTree<T> {\n        return Reflect.getMetadata(PROPERTY_KEY, object) || {};\n    }\n\n    static getTypeFromTree<T>(object: Constructor<T>): Type<T> {\n        const propertyMap = Metabase.getPropertyTree(object);\n        const isEnum = Reflect.getMetadata(ENUM_KEY, object) || false;\n        const prefix = object.name;\n        const builder = new TypeBuilder();\n        builder.setType(prefix);\n        builder.setIsEnum(isEnum);\n        builder.setIsArray(false);\n        builder.setIsSubclass(false, null);\n        builder.setIsNullable(false);\n        builder.setBody(propertyMap);\n        return builder.build();\n    }\n\n    static generateTypeDefinitions<T>(object: Constructor<T>) {\n        return this.createTypeDefinitionFromTree(Metabase.getTypeFromTree(object));\n    }\n\n    private static createTypeDefinitionFromTree<T>(property: Type<T>, prefix?: string): Definition[] {\n        const name = property.isSubclass && prefix ? `${prefix}$${property.type}` : property.type;\n        const definitionType = property.isEnum ? 'enum' : 'interface';\n        const rawDefinition = property.toDefinition();\n\n        const definition: Definition = {\n            name,\n            type: definitionType,\n            definition: rawDefinition,\n        };\n\n        if (property.isEnum) {\n            return [definition];\n        }\n\n        const children: Type<any>[] = property.body\n            ? Object.values(property.body).filter((_: Type<any>) => !_.isPrimitive)\n            : [];\n\n        return [definition, ...children.flatMap((_) => Metabase.createTypeDefinitionFromTree(_, name))];\n    }\n}\n"]}